#!/usr/bin/env bash
main@bashbox%bashbox () 
{ 
    if test "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -lt 43; then
        { 
            printf 'error: %s\n' 'At least bash 4.3 is required to run this, please upgrade bash or use the correct interpreter' 1>&2;
            exit 1
        };
    fi;
    function process::self::exit () 
    { 
        local _r=$?;
        ( kill -USR1 "$___self_PID" 2> /dev/null || : ) & exit $_r
    };
    function process::self::forcekill () 
    { 
        kill -9 "$___self_PID" 2> /dev/null
    };
    function log::error () 
    { 
        local _retcode="${2:-$?}";
        local _exception_line="$1";
        local _source="${BB_ERR_SOURCE:-"${BASH_SOURCE[-1]}"}";
        if [[ ! "$_exception_line" == \(*\) ]]; then
            { 
                printf '[!!!] \033[1;31m%s\033[0m[%s]: %s\n' error "$_retcode" "${_source##*/}[${BASH_LINENO[0]}]: ${BB_ERR_MSG:-"$_exception_line"}" 1>&2;
                if test -v BB_ERR_MSG; then
                    { 
                        echo -e "STACK TRACE: (TOKEN: $_exception_line)" 1>&2;
                        local -i _frame=0;
                        local _treestack='|--';
                        local _line _caller _source;
                        while read -r _line _caller _source < <(caller "$_frame"); do
                            { 
                                printf '%s >> %s\n' "$_treestack ${_caller}" "${_source##*/}:${_line}" 1>&2;
                                _frame+=1;
                                _treestack+='--'
                            };
                        done
                    };
                fi
            };
        else
            { 
                printf '[!!!] \033[1;31m%s\033[0m[%s]: %s\n' error "$_retcode" "${_source##*/}[${BASH_LINENO[0]}]: SUBSHELL EXITED WITH NON-ZERO STATUS" 1>&2
            };
        fi;
        return "$_retcode"
    };
    \command unalias -a || exit;
    set -eEuT -o pipefail;
    shopt -sq inherit_errexit expand_aliases nullglob;
    trap 'exit' USR1;
    trap 'BB_ERR_MSG="UNCAUGHT EXCEPTION" log::error "$BASH_COMMAND" || process::self::exit' ERR;
    ___self="$0";
    ___self_PID="$$";
    ___self_DIR="$(cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd)";
    ___MAIN_FUNCNAME='main@bashbox%bashbox';
    ___self_NAME="BashBox";
    ___self_CODENAME="bashbox";
    ___self_AUTHORS=("AXON <axonasif@gmail.com>");
    ___self_VERSION="0.4.1";
    ___self_DEPENDENCIES=(https://github.com/bashbox/std.git::15dc26b argbash::0.1.1);
    ___self_REPOSITORY="https://github.com/bashbox/bashbox";
    ___self_BASHBOX_COMPAT="0.3.9~";
    function bashbox::build::after () 
    { 
        cp "$_target_workfile" "$_arg_path/$CODENAME";
        chmod +x "$_arg_path/$CODENAME"
    };
    function pkgfun () 
    { 
        ( echo "$@" )
    };
    function bb_bootstrap_header () 
    { 
        if test "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -lt 43; then
            { 
                printf 'error: %s\n' 'At least bash 4.3 is required to run this, please upgrade bash or use the correct interpreter' 1>&2;
                exit 1
            };
        fi;
        function process::self::exit () 
        { 
            local _r=$?;
            ( kill -USR1 "$___self_PID" 2> /dev/null || : ) & exit $_r
        };
        function process::self::forcekill () 
        { 
            kill -9 "$___self_PID" 2> /dev/null
        };
        function log::error () 
        { 
            local _retcode="${2:-$?}";
            local _exception_line="$1";
            local _source="${BB_ERR_SOURCE:-"${BASH_SOURCE[-1]}"}";
            if [[ ! "$_exception_line" == \(*\) ]]; then
                { 
                    printf '[!!!] \033[1;31m%s\033[0m[%s]: %s\n' error "$_retcode" "${_source##*/}[${BASH_LINENO[0]}]: ${BB_ERR_MSG:-"$_exception_line"}" 1>&2;
                    if test -v BB_ERR_MSG; then
                        { 
                            echo -e "STACK TRACE: (TOKEN: $_exception_line)" 1>&2;
                            local -i _frame=0;
                            local _treestack='|--';
                            local _line _caller _source;
                            while read -r _line _caller _source < <(caller "$_frame"); do
                                { 
                                    printf '%s >> %s\n' "$_treestack ${_caller}" "${_source##*/}:${_line}" 1>&2;
                                    _frame+=1;
                                    _treestack+='--'
                                };
                            done
                        };
                    fi
                };
            else
                { 
                    printf '[!!!] \033[1;31m%s\033[0m[%s]: %s\n' error "$_retcode" "${_source##*/}[${BASH_LINENO[0]}]: SUBSHELL EXITED WITH NON-ZERO STATUS" 1>&2
                };
            fi;
            return "$_retcode"
        };
        \command unalias -a || exit;
        set -eEuT -o pipefail;
        shopt -sq inherit_errexit expand_aliases nullglob;
        trap 'exit' USR1;
        trap 'BB_ERR_MSG="UNCAUGHT EXCEPTION" log::error "$BASH_COMMAND" || process::self::exit' ERR
    };
    unset -f bashbox::build::before bashbox::build::after bashbox::run::before bashbox::run::after;
    readonly _bashbox_meta_name="Bashbox.sh";
    readonly _src_dir_name="src";
    readonly _bashbox_home="${HOME:-"${0%/*}"}/.bashbox" && mkdir -p "$_bashbox_home";
    readonly _bashbox_registrydir="$_bashbox_home/registry" && mkdir -p "$_bashbox_registrydir";
    readonly _bashbox_bindir="$_bashbox_home/bin" && mkdir -p "$_bashbox_bindir";
    readonly _bashbox_posix_envfile="$_bashbox_home/env";
    readonly _bashbox_fish_envfile="$_bashbox_home/env.fish";
    readonly _bashbox_compat_var_name="BASHBOX_COMPAT";
    readonly SUBCOMMANDS_DESC=("" "Create a new bashbox project" "Compile a bashbox project" "Cleanup target/ directories" "Install a bashbox project from repo" "Install bashbox into PATH");
    _var_exports=(_bashbox_registrydir);
    for _var in "${_var_exports[@]}";
    do
        { 
            export "$_var"
        };
    done;
    ( for _envfile in "$_bashbox_posix_envfile" "$_bashbox_fish_envfile";
    do
        { 
            if test ! -e "$_envfile"; then
                { 
                    case "$_envfile" in 
                        "$_bashbox_posix_envfile")
                            echo "export PATH=\"$_bashbox_bindir:\$PATH\"" > "$_envfile"
                        ;;
                        "$_bashbox_fish_envfile")
                            echo "set PATH \"$_bashbox_bindir\" \"\$PATH\" && export PATH" > "$_envfile"
                        ;;
                    esac
                };
            fi
        };
    done ) & function log::info () 
    { 
        echo -e "[%%%] \033[1;37minfo\033[0m: $@"
    };
    function log::warn () 
    { 
        echo -e "[***] \033[1;37mwarn\033[0m: $@"
    };
    function println::helpgen () 
    { 
        _positionals=();
        _arg_helpname=;
        _arg_short_desc=;
        _arg_usage=;
        _arg_options_desc=;
        _arg_subcommands=;
        _arg_examples=;
        _arg_footer_msg=;
        function print_help () 
        { 
            printf '%s\n' "<The general help message of my script>";
            printf 'Usage: %s [--short-desc <arg>] [--usage <arg>] [--options-desc <arg>] [--subcommands <arg>] [--examples <arg>] [--footer-msg <arg>] [-h|--help] <helpname>\n' "$0";
            printf '\t%s\n' "-h, --help: Prints help"
        };
        function parse_commandline () 
        { 
            _positionals_count=0;
            while test $# -gt 0; do
                _key="$1";
                case "$_key" in 
                    --short-desc)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_short_desc="$2";
                        shift
                    ;;
                    --short-desc=*)
                        _arg_short_desc="${_key##--short-desc=}"
                    ;;
                    --usage)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_usage="$2";
                        shift
                    ;;
                    --usage=*)
                        _arg_usage="${_key##--usage=}"
                    ;;
                    --options-desc)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_options_desc="$2";
                        shift
                    ;;
                    --options-desc=*)
                        _arg_options_desc="${_key##--options-desc=}"
                    ;;
                    --subcommands)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_subcommands="$2";
                        shift
                    ;;
                    --subcommands=*)
                        _arg_subcommands="${_key##--subcommands=}"
                    ;;
                    --examples)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_examples="$2";
                        shift
                    ;;
                    --examples=*)
                        _arg_examples="${_key##--examples=}"
                    ;;
                    --footer-msg)
                        test $# -lt 2 && println::error "Missing value for the optional argument '$_key'." 1;
                        _arg_footer_msg="$2";
                        shift
                    ;;
                    --footer-msg=*)
                        _arg_footer_msg="${_key##--footer-msg=}"
                    ;;
                    -h | --help)
                        print_help;
                        exit 0
                    ;;
                    -h*)
                        print_help;
                        exit 0
                    ;;
                    *)
                        _last_positional="$1";
                        _positionals+=("$_last_positional");
                        _positionals_count=$((_positionals_count + 1))
                    ;;
                esac;
                shift;
            done
        };
        function handle_passed_args_count () 
        { 
            local _required_args_string="'helpname'";
            test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes println::error "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1;
            test "${_positionals_count}" -le 1 || _PRINT_HELP=yes println::error "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
        };
        function assign_positional_args () 
        { 
            local _positional_name _shift_for=$1;
            _positional_names="_arg_helpname ";
            shift "$_shift_for";
            for _positional_name in ${_positional_names};
            do
                test $# -gt 0 || break;
                eval "$_positional_name=\${1}" || println::error "Error during argument parsing." 1;
                shift;
            done
        };
        parse_commandline "$@";
        handle_passed_args_count;
        assign_positional_args 1 "${_positionals[@]}";
        echo -e "${_arg_helpname}\c";
        if test -n "$_arg_short_desc"; then
            echo -e " - $_arg_short_desc\n";
        else
            echo;
        fi;
        if test -n "$_arg_usage"; then
            echo -e "USAGE:";
            while read -r line; do
                echo -e "    $line";
            done < <(echo "$_arg_usage");
            echo;
        fi;
        for child in "$_arg_options_desc" "$_arg_subcommands";
        do
            if test -n "$child"; then
                local _startString _endString gapVar;
                _startString="$(sed 's|<^>.*||g' <<<"${child}")";
                _endString="$(sed 's|.*<^>||g' <<<"${child}")";
                mapfile -t _startString < <(echo "$_startString");
                mapfile -t _endString < <(echo "$_endString");
                local i=0;
                local firstChild=false;
                ! "$firstChild" && echo -e "OPTIONS:" || echo -e 'SUBCOMMANDS:' && firstChild=true;
                for line in "${_startString[@]}";
                do
                    gapVar="$(
					for t in $(seq $((30 - ${#line}))); do
						echo -n " "
					done
				)";
                    echo -e "    $line${gapVar}${_endString[$i]}";
                    i=$((i+1));
                done;
                echo;
            fi;
        done;
        if test -n "$_arg_examples"; then
            echo -e "EXAMPLES:";
            while read -r line; do
                echo -e "    $line";
            done < <(echo "$_arg_examples");
            echo;
        fi;
        if test -n "$_arg_footer_msg"; then
            echo -e "$_arg_footer_msg\n";
        fi
    };
    readonly RC='\033[0m' RED='\033[0;31m' BRED='\033[1;31m' GRAY='\033[1;30m';
    readonly BLUE='\033[0;34m' BBLUE='\033[1;34m' CYAN='\033[0;34m' BCYAN='\033[1;34m';
    readonly WHITE='\033[1;37m' GREEN='\033[0;32m' BGREEN='\033[1;32m' YELLOW='\033[1;33m';
    readonly PURPLE='\033[0;35m' BPURPLE='\033[1;35m' ORANGE='\033[0;33m';
    function io::file::check_newline () 
    { 
        local _input="$1";
        if ! [[ $(tail -c1 "$_input" | wc -l) -gt 0 ]]; then
            { 
                echo >> "$_input"
            };
        fi
    };
    function get_temp::file () 
    { 
        if test -w /tmp; then
            { 
                printf '/tmp/%s\n' ".$$_$((RANDOM * RANDOM))"
            };
        else
            if res="$(mktemp -u)"; then
                { 
                    printf '%s\n' "$res" && unset res
                };
            else
                { 
                    return 1
                };
            fi;
        fi
    };
    function get_temp::dir () 
    { 
        if test -w /tmp; then
            { 
                printf '%s\n' '/tmp'
            };
        else
            if res="$(mktemp -u)"; then
                { 
                    printf '%s\n' "${res%/*}" && unset res
                };
            else
                { 
                    return 1
                };
            fi;
        fi
    };
    function trap::stack_name () 
    { 
        local sig=${1//[^a-zA-Z0-9]/_};
        printf '__trap_stack_%s\n' "$sig"
    };
    function trap::extract () 
    { 
        printf '%s\n' "${3:-}"
    };
    function trap::get () 
    { 
        eval "trap::extract $(trap -p "$1")"
    };
    function trap::push () 
    { 
        local new_trap="$1" && shift;
        local sig;
        for sig in $*;
        do
            local stack_name="$(trap::stack_name "$sig")";
            local old_trap=$(trap::get "$sig");
            if test ! -v "$stack_name"; then
                { 
                    eval "${stack_name}=()"
                };
            fi;
            eval "${stack_name}"'[${#'"${stack_name}"'[@]}]=${old_trap:-}';
            trap "${new_trap}" "$sig";
        done
    };
    function trap::append () 
    { 
        local new_trap="$1" && shift;
        local sig;
        for sig in $*;
        do
            if [[ -z "$(trap::get "$sig")" ]]; then
                trap::push "$new_trap" "$sig";
            else
                trap::push "$(trap::get $sig) ; $new_trap" "$sig";
            fi;
        done
    };
    function lockfile () 
    { 
        local name="$1";
        local lock_file;
        lock_file="$(get_temp::dir)/.${name}.lock";
        if test -e "$lock_file"; then
            { 
                if ! { 
                    kill -0 "$(< "$lock_file")"
                }; then
                    { 
                        rm "$lock_file" 2> /dev/null || :
                    };
                fi;
                log::info "Awaiting for another ${name} job to finish"
            };
        fi;
        for _ in {1..5};
        do
            { 
                while { 
                    kill -0 "$(< "$lock_file")"
                }; do
                    { 
                        sleep 0.5
                    };
                done
            };
        done;
        until ( set -o noclobber && printf '%s\n' "$$" > "$lock_file" ); do
            { 
                sleep 0.5
            };
        done;
        trap::append "rm -f '$lock_file' 2>/dev/null" ${SIGNALS:-EXIT}
    } 2> /dev/null;
    function sleep () 
    { 
        [[ -n "${_snore_fd:-}" ]] || { 
            exec {_snore_fd}<> <(:)
        } 2> /dev/null || { 
            local fifo;
            fifo=$(mktemp -u);
            mkfifo -m 700 "$fifo";
            exec {_snore_fd}<> "$fifo";
            rm "$fifo"
        };
        IFS='' read ${1:+-t "$1"} -u $_snore_fd || :
    };
    function begins_with_short_option () 
    { 
        local first_option all_short_options='h';
        first_option="${1:0:1}";
        test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
    };
    function subcommand::new () 
    { 
        _positionals=();
        _arg_path=;
        _arg_codename=;
        function print_help () 
        { 
            println::helpgen "${_self_name^^}-${_subcommand_argv^^}" --short-desc "${SUBCOMMANDS_DESC[1]}" --usage "${_self_name} ${_subcommand_argv} [OPTIONAL-OPTIONS] <path>" --options-desc "-c, --codename<^>Avoid directory-as-codename
-h, --help<^>Prints this help information" --examples "### The basic way:
${YELLOW}${_self_name} ${_subcommand_argv} awesome_project${RC}

### Pre-setting project codename, avoiding directory-path as codename:
${YELLOW}${_self_name} ${_subcommand_argv} --codename cake awesome_project${RC}"
        };
        function parse_commandline () 
        { 
            _positionals_count=0;
            while test $# -gt 0; do
                _key="$1";
                case "$_key" in 
                    --codename | -c)
                        test $# -lt 2 && log::error "Missing value for the optional argument '$_key'." 1 || exit;
                        _arg_codename="$2";
                        shift
                    ;;
                    --codename=*)
                        _arg_codename="${_key##--codename=}"
                    ;;
                    -h | --help)
                        print_help;
                        exit 0
                    ;;
                    -h*)
                        print_help;
                        exit 0
                    ;;
                    *)
                        _last_positional="$1";
                        _positionals+=("$_last_positional");
                        _positionals_count=$((_positionals_count + 1))
                    ;;
                esac;
                shift;
            done
        };
        function handle_passed_args_count () 
        { 
            local _required_args_string="'path'";
            test "${_positionals_count}" -ge 1 || log::error "Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1 || exit;
            test "${_positionals_count}" -le 1 || log::error "There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1 || exit
        };
        function assign_positional_args () 
        { 
            local _positional_name _shift_for=$1;
            _positional_names="_arg_path ";
            shift "$_shift_for";
            for _positional_name in ${_positional_names};
            do
                test $# -gt 0 || break;
                eval "$_positional_name=\${1}" || log::error "Error during argument parsing." 1 || exit;
                shift;
            done
        };
        parse_commandline "$@";
        handle_passed_args_count;
        assign_positional_args 1 "${_positionals[@]}";
        _path_codename="${_arg_path##*/}";
        : "${_arg_codename:="$_path_codename"}";
        _arg_codename="$(tr -d '[:space:]' <<<"${_arg_codename,,}")";
        if test -e "$_arg_path"; then
            log::error "Destination \`$_arg_path\` already exists.\n\t  You may either remove that project dir or use a different path for setup." 1 || exit;
        fi;
        log::info "Setting up project at \`$_arg_path\`";
        mkdir -p "$_arg_path" || log::error "Failed to initialize the project directory" 1 || exit;
        mkdir -p "$_arg_path/$_src_dir_name";
        cat <<'EOF' > "$_arg_path/$_src_dir_name/main.sh"
function main() {
	echo "Hello world";
}

EOF

        cat <<EOF > "$_arg_path/$_bashbox_meta_name"
NAME="$_path_codename"
CODENAME="$_arg_codename"
AUTHORS=("AXON <axonasif@gmail.com>")
VERSION="1.0"
DEPENDENCIES=()
REPOSITORY=""
BASHBOX_COMPAT="${___self_VERSION}~"
EOF

        log::info "Initializing git version control for your project";
        if command -v git > /dev/null; then
            git init "$_arg_path" > /dev/null || { 
                _r=$?;
                rm -r "$_arg_path";
                log::error "Failed to initialize git at \`$_arg_path\`" $_r || exit
            };
            echo -e '/target' > "$_arg_path/.gitignore";
        else
            rm -r "$_arg_path";
            log::error "git does not seem to be available, please install it" 1 || exit;
        fi
    };
    function subcommand::install () 
    { 
        function trim_leading_trailing () 
        { 
            local _stream="${1:-}";
            local _stdin;
            if test -z "${_stream}"; then
                { 
                    read -r _stdin;
                    _stream="$_stdin"
                };
            fi;
            _stream="${_stream#"${_stream%%[![:space:]]*}"}";
            _stream="${_stream%"${_stream##*[![:space:]]}"}";
            printf '%s\n' "$_stream"
        };
        function trim_string () 
        { 
            : "${1#"${1%%[![:space:]]*}"}";
            : "${_%"${_##*[![:space:]]}"}";
            printf '%s\n' "$_"
        };
        function trim_all () 
        { 
            set -f;
            set -- $*;
            printf '%s\n' "$*";
            set +f
        };
        function trim_quotes () 
        { 
            : "${1//\'}";
            printf '%s\n' "${_//\"}"
        };
        function string::matches () 
        { 
            local _string _match _arg;
            local _print=false;
            for _arg in "${@}";
            do
                { 
                    case "$_arg" in 
                        --print | -p)
                            shift;
                            _print=true
                        ;;
                    esac
                };
            done;
            if [[ $1 =~ $2 ]]; then
                { 
                    if [ "$_print" == "true" ]; then
                        { 
                            echo "${BASH_REMATCH[@]}"
                        };
                    fi;
                    return 0
                };
            else
                { 
                    return 1
                };
            fi
        };
        lockfile "install";
        local _arg_force=off;
        local _arg_syncmeta=off;
        local _arg_eval;
        for _arg_eval in "force" "syncmeta";
        do
            { 
                case "$@" in 
                    *${_arg_eval}*)
                        eval "_arg_${_arg_eval}=on"
                    ;;
                esac
            };
        done;
        unset _arg_eval;
        local _github_api_root _registry_meta_file;
        readonly _registry_meta_file="${_bashbox_home}/registry.meta" && touch "$_registry_meta_file";
        readonly _github_api_root="https://api.github.com";
        function box::syncmeta () 
        { 
            local _registry_meta_url _registry_lastsync_file;
            readonly _registry_meta_url="https://raw.githubusercontent.com/bashbox/registry/main/registry.meta";
            readonly _registry_lastsync_file="${_bashbox_home}/.registry.lastsync" && touch "$_registry_lastsync_file";
            local _user_repo _check_file _branch;
            readonly _user_repo="bashbox/registry";
            readonly _check_file="registry.meta";
            readonly _branch="main";
            local _lock_file="$_bashbox_home/.registry.lastdate";
            local _date && _date="$(date '+%d-%m')";
            if test "$_arg_offline" == "off"; then
                { 
                    touch "$_lock_file";
                    if [ "$_arg_syncmeta" == "on" ] || [ "$(< "$_lock_file")" != "$_date" ]; then
                        { 
                            echo "$_date" > "$_lock_file";
                            log::info "Syncing repository metadata";
                            local _local_sha _remote_sha;
                            _local_sha="$(< "$_registry_lastsync_file")";
                            _remote_sha="$(curl --silent "${_github_api_root}/repos/${_user_repo}/contents/${_check_file}?ref=${_branch}" 								| head -n4 | grep -I '"sha":' | sed -E 's/.*"([^"]+)".*/\1/')" || return 0;
                            readonly _local_sha _remote_sha;
                            if test "$_arg_syncmeta" == "on" || test "$_local_sha" != "$_remote_sha"; then
                                { 
                                    log::info "Updating registry.meta";
                                    curl --silent -o "$_registry_meta_file" -L "$_registry_meta_url";
                                    echo "$_remote_sha" > "$_registry_lastsync_file"
                                };
                            fi
                        };
                    fi
                };
            fi
        };
        function box::parsemeta () 
        { 
            local _input="$1";
            local _box_dir _box_name;
            local _repo_source _repo_url _tag_name;
            IFS='|' read -r _repo_source _tag_name <<< "${_input//::/|}";
            : "${_tag_name:="HEAD"}";
            if string::matches "$_repo_source" '^file://.*'; then
                { 
                    _box_dir="$_repo_source";
                    if test ! -e "$_box_dir"; then
                        { 
                            log::error "$_box_dir does not exist" 1 || exit
                        };
                    fi;
                    _arg_force=off;
                    _repo_url=;
                    _box_name="${_box_dir##*/}"
                };
            else
                if string::matches "$_repo_source" '^.*://.*'; then
                    { 
                        local _repo_user _repo_name;
                        _repo_source="${_repo_source%.git}";
                        _repo_url="${_repo_source}";
                        IFS='|' read -r _repo_user _repo_name < <(
				_user="${_repo_source%/*}" && _user="${_user##*/}";
				echo -e "${_user}|${_repo_source##*/}";
			);
                        _box_dir="$_bashbox_registrydir/${_repo_user}_${_repo_name}-${_tag_name}";
                        _box_name="${_repo_name}"
                    };
                else
                    if string::matches "$_repo_source" "[a-zA-Z0-9_]"; then
                        { 
                            _repo_url="$(grep ".*/${_repo_source}$" "$_registry_meta_file")" || log::error "No such box as $_repo_source was found in the registry" 1 || exit;
                            _box_dir="$_bashbox_registrydir/${_repo_source}-${_tag_name}";
                            _box_name="${_repo_source##*/}"
                        };
                    fi;
                fi;
            fi;
            echo "${_box_name}|${_box_dir}|${_repo_url}|${_tag_name}"
        };
        box::syncmeta;
        local _box _box_dir _gitmod_file;
        local _path _url _install_path _install_executable _built_executable;
        for _box in "${@}";
        do
            { 
                if [[ "$_box" =~ ^-- ]]; then
                    { 
                        continue
                    };
                fi;
                local _box_name _box_dir _repo_url _tag_name;
                IFS='|' read -r _box_name _box_dir _repo_url _tag_name <<< "$(box::parsemeta "$_box")";
                if test "${EXPORT_USEMOL:-}" == "true"; then
                    { 
                        export "_usemol_${_box_name}=${_box_dir}"
                    };
                fi;
                if test -e "$_box_dir"; then
                    { 
                        if [ "$_arg_force" == "off" ] && [ -e "$_box_dir/$_bashbox_meta_name" ]; then
                            { 
                                if test ! -v EXPORT_USEMOL; then
                                    { 
                                        log::warn "$_box_name already exists"
                                    };
                                fi;
                                continue
                            };
                        else
                            { 
                                rm -rf "$_box_dir"
                            };
                        fi
                    };
                fi;
                mkdir -p "$_box_dir";
                log::info "Downloading box $_box_name $_tag_name";
                curl --silent -L "${_repo_url}/archive/${_tag_name}.tar.gz" | tar --strip-components=1 -C "$_box_dir" -xpzf -;
                _gitmod_file="$_box_dir/.gitmodules";
                if test -e "$_gitmod_file"; then
                    { 
                        log::info "Resolving git submodules";
                        while read -r _line; do
                            { 
                                _line="${_line%%:*}";
                                _path="$(sed "${_line}q;d" "$_gitmod_file" 					| cut -d '=' -f2 | trim_leading_trailing)";
                                _url="$(sed "$(( _line + 1 ))q;d" "$_gitmod_file" 					| cut -d '=' -f2 | trim_leading_trailing)";
                                _install_path="${_box_dir}/${_path}";
                                log::info "Downloading git submodule: $_path";
                                mkdir -p "$_install_path";
                                curl --silent -L "${_url}/archive/${_tag_name}.tar.gz" | tar --strip-components=1 -C "$_install_path" -xpzf -
                            };
                        done < <(grep -n 'path.*=' "$_gitmod_file")
                    };
                fi;
                if test -e "$_box_dir/$_src_dir_name/main.sh" && test ! -v "EXPORT_USEMOL"; then
                    { 
                        log::info "Compiling $_box in release mode";
                        ( main -C "$_box_dir" build --release ) || { 
                            log::error "Errors were found while compiling $_box, operation failed" 1 || exit
                        };
                        source "$_box_dir/$_bashbox_meta_name";
                        _built_executable="$_box_dir/target/release/$CODENAME";
                        _install_executable="$_bashbox_bindir/$CODENAME";
                        chmod +x "$_built_executable";
                        ln -srf "$_built_executable" "$_install_executable";
                        chmod +x "$_install_executable";
                        log::info "$_box was successfully installed as $CODENAME"
                    };
                else
                    { 
                        log::info "$_box was installed as a library"
                    };
                fi
            };
        done
    };
    function subcommand::build () 
    { 
        lockfile "build";
        function print_help () 
        { 
            println::helpgen ${_self_name^^}-${_subcommand_argv^^} --short-desc "${SUBCOMMANDS_DESC[3]}" --usage "${_self_name} ${_subcommand_argv} [OPTIONAL-OPTIONS] <path>" --options-desc "--release<^>Build in release mode
--debug<^>Build in debug mode(default)
--run<^>Auto-run the executable after build
--<^>Pass arguments to your compiled program
-h, --help<^>Prints this help information" --examples "### The basic way:
# Buld the project in your current directory hierarchy in release-mode
${YELLOW}${_self_name} ${_subcommand_argv} --release${RC}

### Build project from a specified directory:
${YELLOW}${_self_name} ${_subcommand_argv} --release /home/me/awesome_project${RC}

### Pass arguments to the compiled executable and auto-run it after build
${YELLOW}${_self_name} ${_subcommand_argv} --release --run -- arg1 arg2 \"string arg\" and-so-on${RC}
"
        };
        clap "$@";
        local _orig_PWD="$PWD";
        function Resolve::Colons () 
        { 
            local result="$1";
            if [[ "$result" =~ (use\ )?([^[:space:]]+)\;$ ]]; then
                { 
                    result="${BASH_REMATCH[2]//::/\/}";
                    result="${result/box\//}";
                    result="${result//\/\*/}"
                };
            fi;
            printf '%s\n' "$result"
        };
        function perform_task () 
        { 
            local _task="bashbox::$1";
            if declare -F "$_task" > /dev/null; then
                { 
                    "$_task"
                };
            fi
        };
        function Resolve::UseSymbols () 
        { 
            local _input="$1";
            local _parsed_input;
            _parsed_input="$(Resolve::Colons "$_input")";
            local _parsed_input_name="${_parsed_input##*/}" && { 
                local _modname="${_parsed_input_name}";
                _parsed_input="${_parsed_input/${_parsed_input_name}/${_parsed_input_name#_}}";
                unset _parsed_input_name
            };
            local _ref="_usemol_${_parsed_input%%/*}";
            local _src && { 
                if [[ "$_input" =~ use\ box:: ]]; then
                    { 
                        _src="${PWD%%/src*}/src"
                    };
                else
                    if test -v "$_ref"; then
                        { 
                            local _reg_mod_path="${!_ref}";
                            local _reg_mod_target="${_local_build_registrydir}/${_reg_mod_path##*/}";
                            if test ! -e "$_reg_mod_target"; then
                                { 
                                    cp -r "$_reg_mod_path" "$_reg_mod_target"
                                };
                            fi;
                            _src="$_reg_mod_target/src";
                            _parsed_input="${_parsed_input#*/}"
                        };
                    else
                        { 
                            _src="$PWD"
                        };
                    fi;
                fi;
                _parsed_input="$_src/$_parsed_input"
            };
            if test "${_modname::1}" == "_" || [[ "$_input" =~ ^[[:space:]]+use ]] || ! [[ "$(< "${_used_symbols_statfile}")" =~ "${_parsed_input}.sh" ]]; then
                { 
                    if test "$_arg_verbose" == "off"; then
                        { 
                            echo -e "   ${BGREEN}Compiling${RC} $_modname"
                        };
                    else
                        { 
                            echo -e "---------- $_modname"
                        };
                    fi;
                    if test ! -e "${_parsed_input}.sh" && test ! -e "${_parsed_input}"; then
                        { 
                            log::error "$_input is missing" 5 || exit
                        };
                    fi;
                    if [[ "$_input" =~ \*\;$ ]]; then
                        { 
                            printf '\n' > "$_compiled_mod_bundle.sh";
                            for _modFile in "$_parsed_input/"*;
                            do
                                { 
                                    printf '%s\n' "$(< "$modFile")" >> "$_compiled_mod_bundle"
                                };
                            done;
                            _parsed_input="$_compiled_mod_bundle"
                        };
                    else
                        if test ! -e "${_parsed_input}.sh" && test -d "$_parsed_input"; then
                            { 
                                _parsed_input="$_parsed_input/mod"
                            };
                        fi;
                    fi;
                    cd "$(dirname "$_parsed_input")";
                    if test "$_arg_verbose" == "on"; then
                        { 
                            echo -e "${RED}PWD${RC}: $PWD";
                            echo -e "${CYAN}File${RC}: ${_parsed_input}.sh"
                        };
                    fi;
                    mapfile -t _use_symbols < <(grep -w -I -x -E '^\s+use .*;$|^use .*;$' "${_parsed_input}.sh" || true);
                    : ${_last_parsed_input:="${_parsed_input}"};
                    if test "$_arg_verbose" == "on"; then
                        { 
                            echo -e "${PURPLE}Caller${RC}: $_last_parsed_input\n"
                        };
                    fi;
                    for _symbol in "${_use_symbols[@]}";
                    do
                        ( _last_parsed_input="${_parsed_input}";
                        Resolve::UseSymbols "$_symbol" ) || exit 1;
                    done;
                    if test "${_parsed_input}.sh" != "${_last_parsed_input}.sh"; then
                        { 
                            bash -n "${_parsed_input}.sh" || log::error "Syntax errors were found" || exit 1;
                            local _insert_stream _input_stream;
                            _insert_stream=$(< "${_parsed_input}.sh");
                            _input_stream=$(< "${_last_parsed_input}.sh");
                            printf '%s\n' "${_input_stream/$_input/$_insert_stream}" > "${_last_parsed_input}.sh";
                            unset _insert_stream _input_stream;
                            printf '%s\n' "${_parsed_input}.sh" >> "$_used_symbols_statfile"
                        };
                    fi;
                    if test "$_arg_verbose" == "on"; then
                        { 
                            echo "$_parsed_input.sh ++ ${_last_parsed_input}.sh($_input)"
                        };
                    fi
                };
            else
                { 
                    local _input_stream;
                    _input_stream=$(< "${_last_parsed_input}.sh");
                    printf '%s\n' "${_input_stream/$_input/}" > "${_last_parsed_input}.sh";
                    unset _input_stream
                };
            fi
        };
        if test -e "$_arg_path/build.sh"; then
            { 
                source "$_arg_path/build.sh"
            };
        fi;
        perform_task "build::before";
        cd "$_target_workdir";
        Resolve::UseSymbols "main";
        local _bb_bootstrap;
        _bb_bootstrap=$(declare -f bb_bootstrap_header) && { 
            _bb_bootstrap="${_bb_bootstrap#*{}";
            _bb_bootstrap="${_bb_bootstrap%\}}"
        };
        local _ran="$RANDOM";
        local _main_funcname="main@bashbox%${CODENAME}";
        local _tmp_target_workfile="$_target_workdir/.${NAME}.$_ran";
        if test -e /usr/bin/env; then
            { 
                : '#!/usr/bin/env bash'
            };
        else
            { 
                : '#!'"$(command -v env) bash"
            };
        fi;
        local _shebang="$_";
        printf '%s\n' "$_shebang" '# This is a machine compiled script, do not attempt to modify' "function ${_main_funcname}() {" "${_bb_bootstrap}" '___self="$0";' '___self_PID="$$";' '___self_DIR="$(cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd)";' "___MAIN_FUNCNAME='$_main_funcname';" > "$_tmp_target_workfile";
        while read -r _line; do
            { 
                if [[ "$_line" =~ ^[A-Z].*= ]]; then
                    { 
                        printf '%s\n' "___self_${_line}" >> "$_tmp_target_workfile"
                    };
                else
                    { 
                        printf '%s\n' "$_line" >> "$_tmp_target_workfile"
                    };
                fi
            };
        done < "$_bashbox_meta" && unset _line;
        cat "$_tmp_target_workfile" "$_target_workdir/main.sh" > "$_target_workfile";
        printf '%s\n' 'main "$@";' 'wait;' 'exit;' '}' >> "$_target_workfile";
        rm "$_tmp_target_workfile";
        if test "$_build_variant" == "release"; then
            { 
                source "$_target_workfile";
                printf '%s\n' "$_shebang" > "$_target_workfile";
                declare -f "$_main_funcname" >> "$_target_workfile"
            };
        fi;
        printf '"%s" "$@";\n' "${_main_funcname}" >> "$_target_workfile";
        sed -i -E 's|^(\s+)?use .*;$||g' "$_target_workfile";
        perform_task "build::after";
        if declare -F "bashbox_after_build" > /dev/null; then
            { 
                bashbox_after_build
            };
        fi;
        chmod +x "$_target_workfile";
        if test "$_arg_verbose" == "off"; then
            { 
                case "$_build_variant" in 
                    "release")
                        : "optimized"
                    ;;
                    *)
                        : "unoptimized + debuginfo"
                    ;;
                esac;
                local _is_optimized="$_";
                echo -e "   ${BGREEN}Finished${RC} $_build_variant [${_is_optimized}] target(s) in ${SECONDS}s"
            };
        fi;
        if test "$_arg_run" == "on"; then
            { 
                perform_task "run::before";
                cd "$_orig_PWD";
                "$_target_workfile" "${_run_target_args[@]}" || log::warn "Target executable exited with error code $?";
                perform_task "run::after"
            };
        fi
    };
    function subcommand::run () 
    { 
        subcommand::build --run "$@";
        return;
        function print_help () 
        { 
            println::helpgen ${_self_name^^}-${_subcommand_argv^^} --short-desc "${SUBCOMMANDS_DESC[2]}" --usage "${_self_name} ${_subcommand_argv} [OPTIONAL-OPTIONS] <path>" --options-desc "--release<^>Run in release mode
--debug<^>Run in debug mode(default)
--<^>Pass arguments to your compiled program
-h, --help<^>Prints this help information" --examples "### The basic way:
# Run the project in your current directory hierarchy in release-mode
${YELLOW}${_self_name} ${_subcommand_argv} --release${RC}

### Run project from a specified directory:
${YELLOW}${_self_name} ${_subcommand_argv} --release /home/me/awesome_project${RC}

### Pass arguments to the compiled executable
${YELLOW}${_self_name} ${_subcommand_argv} --release -- arg1 arg2 \"string arg\" and-so-on${RC}
"
        };
        function __use_func () 
        { 
            for _input in "${@}";
            do
                { 
                    local _input="$_input";
                    local _ref="_usemol_${_input%%::*}";
                    local _src && { 
                        if grep "^box::.*" <<< "$_input" > /dev/null; then
                            { 
                                _src="$_main_src_dir"
                            };
                        else
                            if test -v "$_ref"; then
                                { 
                                    _src="${!_ref}";
                                    _input="${_input#*::}"
                                };
                            else
                                { 
                                    _src="$(readlink -f "${BB_SOURCE}")" && _src="${_src%/*}"
                                };
                            fi;
                        fi
                    };
                    local _parsed_input && _parsed_input="$(sed "s|box::||g; s|::|/|g" <<<"$_input")";
                    local _parsed_input_name="${_parsed_input##*/}";
                    _parsed_input="$(sed "s|${_parsed_input_name}$|${_parsed_input_name#_}|" <<<"$_parsed_input")";
                    unset _parsed_input_name;
                    function source_fromFile () 
                    { 
                        local _mod="$1";
                        local _modname="${_input##*::}";
                        function source_call () 
                        { 
                            builtin source "${_mod}.sh" "${BB_USE_ARGS[@]}" || { 
                                log::error "Syntax/internal errors were detected in $_mod" || exit
                            };
                            echo "$_mod" >> "$_used_symbols_statfile" || { 
                                log::error "Failed to register $_mod in log" || exit
                            }
                        };
                        if test "${_modname::1}" == "_"; then
                            { 
                                source_call
                            };
                        else
                            if ! grep "^${_mod}$" "$_used_symbols_statfile" > /dev/null; then
                                { 
                                    source_call
                                };
                            fi;
                        fi
                    };
                    function source_fromDir () 
                    { 
                        local _dir="$1";
                        for _mod in "$_dir/"*;
                        do
                            { 
                                source_fromFile "${_mod%.sh}"
                            };
                        done
                    };
                    function fetchLib_fromPath () 
                    { 
                        local _mod="$1";
                        local _paths;
                        local _found_file_mods=();
                        local _found_dir_mods=();
                        mapfile -t _paths < <(sed 's|:|\n|g' <<<"${BASHBOX_LIB_PATH:-}");
                        for _path in "${_paths[@]}";
                        do
                            { 
                                if test -e "$_path/$_mod"; then
                                    { 
                                        _found_file_mods+=("$_path/$_mod");
                                        break
                                    };
                                else
                                    if test -d "$_path/$_mod"; then
                                        { 
                                            _found_dir_mods+=("$_path/$_mod");
                                            break
                                        };
                                    fi;
                                fi
                            };
                        done;
                        if test -n "${_found_file_mods[*]}" || test -n "${_found_dir_mods[*]}"; then
                            { 
                                for _mod in "${_found_file_mods[@]}";
                                do
                                    { 
                                        source_fromFile "$_mod"
                                    };
                                done;
                                for _mod in "${_found_dir_mods[@]}";
                                do
                                    { 
                                        source_fromDir "$_mod"
                                    };
                                done;
                                return 0
                            };
                        else
                            { 
                                return 1
                            };
                        fi
                    };
                    if test -e "$_src/${_parsed_input}.sh"; then
                        { 
                            source_fromFile "$_src/${_parsed_input}"
                        };
                    else
                        if test -e "$_src/${_parsed_input}/mod.sh"; then
                            { 
                                source_fromFile "${_src}/${_parsed_input}/mod"
                            };
                        else
                            if test -e "$_bashbox_registrydir/${_parsed_input}.sh"; then
                                { 
                                    source_fromFile "$_bashbox_registrydir/${_parsed_input}"
                                };
                            else
                                if grep '/\*$' <<< "$_parsed_input" > /dev/null; then
                                    { 
                                        local _dir;
                                        _dir="$(sed 's|/\*$||' <<<"$_parsed_input")";
                                        if test -d "$_src/$_dir"; then
                                            { 
                                                source_fromDir "$_src/$_dir"
                                            };
                                        else
                                            if test -d "$_bashbox_registrydir/$_dir"; then
                                                { 
                                                    source_fromDir "$_bashbox_registrydir/$_dir"
                                                };
                                            else
                                                { 
                                                    log::error "No such module tree as $_input was found" || exit
                                                };
                                            fi;
                                        fi
                                    };
                                else
                                    { 
                                        log::error "No such module as $_input was found" || exit
                                    };
                                fi;
                            fi;
                        fi;
                    fi
                };
            done;
            unset BB_USE_ARGS
        };
        clap "$@";
        cat <<'EOF' > "$_target_workfile"
___self="$0";
EOF

        cat "$_bashbox_meta" >> "$_target_workfile";
        declare -f bb_bootstrap_header | tail -n +3 | head -n -1 >> "$_target_workfile";
        cat <<'EOF' >> "$_target_workfile"
	alias use='BB_USE_ARGS=("$@"); BB_SOURCE="${BASH_SOURCE[0]}" __use_func';
	_main_src_dir="$(dirname "$(readlink -f "$0")")";
	_used_symbols_statfile="$_main_src_dir/.used_symbols";
EOF

        declare -f 'log::error' >> "$_target_workfile";
        declare -f __use_func >> "$_target_workfile";
        cat "$_target_workdir/main.sh" >> "$_target_workfile";
        echo -e "\nmain \"\$@\";" >> "$_target_workfile";
        chmod +x "$_target_workfile";
        "$_target_workfile" "${_run_target_args[@]}"
    };
    function subcommand::selfinstall () 
    { 
        local _arg_eval;
        for _arg_eval in "no-modify-path";
        do
            { 
                case "$@" in 
                    *${_arg_eval}*)
                        eval "_arg_${_arg_eval//-/_}=on"
                    ;;
                esac
            };
        done;
        unset _arg_eval;
        local _path _paths;
        local _target_install_dir;
        IFS=':' read -ra _paths <<< "$PATH";
        for _path in "${_paths[@]}";
        do
            { 
                if test -w "$_path"; then
                    { 
                        _target_install_dir="$_path";
                        break
                    };
                fi
            };
        done;
        if ! test -v _target_install_dir; then
            { 
                log::warn "Failed to retrieve a writable existing PATH directory";
                log::info "Falling back to $_bashbox_bindir";
                _target_install_dir="$_bashbox_bindir" && local _self_created_path=true
            };
        fi;
        function check_shellrc_key () 
        { 
            local _input_file="$1";
            grep -q "source.*\.bashbox/env" "$_input_file" 2> /dev/null
        };
        if test ! -v _arg_no_modify_path; then
            { 
                local _shellrcs=("$HOME/.bashrc" "$HOME/.kshrc" "$HOME/.zshrc" "$HOME/.config/fish/config.fish");
                for _shellrc in "${_shellrcs[@]}";
                do
                    { 
                        if ! check_shellrc_key "$_shellrc"; then
                            { 
                                mkdir -p "${_shellrc%/*}";
                                case "$_shellrc" in 
                                    "${_shellrcs[0]}" | "${_shellrcs[1]}" | "${_shellrcs[2]}")
                                        printf 'source "%s";\n' "$_bashbox_posix_envfile" >> "$_shellrc"
                                    ;;
                                    "${_shellrcs[3]}")
                                        printf 'source "%s";\n' "$_bashbox_fish_envfile" >> "$_shellrc"
                                    ;;
                                esac
                            };
                        fi
                    };
                done
            };
        fi;
        log::info "Installing to $_target_install_dir";
        local _target_full_path="$_target_install_dir/$___self_CODENAME";
        rm -f "$_target_full_path";
        local _shebang && _shebang='#!'"$(command -v env) bash";
        printf '%s\n' "$_shebang" "$(declare -f "${___MAIN_FUNCNAME}")" "${___MAIN_FUNCNAME}"' "$@";' > "$_target_full_path";
        chmod +x "$_target_full_path";
        if test -v _self_created_path; then
            { 
                log::info "Restart your shell to update PATH env for bashbox"
            };
        fi;
        log::info "Installation complete, run \`$___self_CODENAME --help\` to get started"
    };
    function subcommand::clean () 
    { 
        function print_help () 
        { 
            println::helpgen ${_self_name^^}-${_subcommand_argv^^} --short-desc "${SUBCOMMANDS_DESC[4]}" --usage "${_self_name} $_subcommand_argv <path>" --examples "### The basic way:
${YELLOW}${_self_name} ${_subcommand_argv}${RC} # Cleans the project in your current directory

### Clean project from a specified directory:
${YELLOW}${_self_name} ${_subcommand_argv} /home/me/awesome_project${RC}"
        };
        clap "$@";
        rm -rf "$_target_dir"
    };
    function clap () 
    { 
        _arg_debug="off";
        _arg_release="off";
        _arg_run="off";
        function parse_commandline () 
        { 
            _positionals_count=0;
            while test $# -gt 0; do
                { 
                    _key="$1";
                    case "$_key" in 
                        --debug)
                            _arg_debug="on"
                        ;;
                        --release)
                            _arg_release="on"
                        ;;
                        --run)
                            _arg_run="on"
                        ;;
                        --help)
                            print_help && exit 0
                        ;;
                        --)
                            return 0
                        ;;
                        *)
                            _last_positional="$1";
                            _positionals+=("$_last_positional");
                            _positionals_count=$((_positionals_count + 1))
                        ;;
                    esac;
                    shift
                };
            done
        };
        function parse_runargs () 
        { 
            for _arg in "${@}";
            do
                { 
                    if test "$_arg" != '--'; then
                        { 
                            shift
                        };
                    else
                        { 
                            shift;
                            _run_target_args=("$@");
                            break
                        };
                    fi
                };
            done
        };
        parse_commandline "$@";
        parse_runargs "$@";
        function gettop () 
        { 
            local TOPFILE="$_bashbox_meta_name";
            local TOPDIR="$_src_dir_name";
            local TOP=;
            local T;
            if [ -n "$TOP" ] && [ -f "$TOP/$TOPFILE" ] && [ -d "$TOPFILE" ]; then
                { 
                    cd "$TOP";
                    echo "$PWD"
                };
            else
                if [ -f "$TOPFILE" ] && [ -d "$TOPDIR" ]; then
                    { 
                        echo "$PWD";
                        cd "$PWD"
                    };
                else
                    { 
                        local HERE="$PWD";
                        while [ \( ! \( -f "$TOPFILE" -a "$TOPDIR" \) \) -a \( "$PWD" != "/" \) ]; do
                            { 
                                cd ..;
                                T="$(cd -- "$PWD" && pwd)"
                            };
                        done;
                        cd "$HERE";
                        if [ -f "$T/$TOPFILE" ] && [ -d "$T/$TOPDIR" ]; then
                            { 
                                echo "$T"
                            };
                        fi
                    };
                fi;
            fi
        };
        : "${_arg_path:="$PWD"}";
        _arg_path="$(cd -- "$_arg_path" && pwd)";
        if test ! -d "$_arg_path/$_src_dir_name" || test ! -e "$_arg_path/$_bashbox_meta_name"; then
            { 
                _top="$(gettop)";
                if test -n "$_top"; then
                    { 
                        _arg_path="$_top";
                        unset _top
                    };
                else
                    { 
                        log::error "$_arg_path is not a valid bashbox project" 1 || exit
                    };
                fi
            };
        fi;
        _src_dir="$_arg_path/$_src_dir_name";
        _target_dir="$_arg_path/target";
        _target_debug_dir="$_target_dir/debug";
        _bashbox_meta="$_arg_path/$_bashbox_meta_name";
        _target_release_dir="$_target_dir/release";
        case "${FUNCNAME[1]}" in 
            "subcommand::build" | "subcommand::run")
                _build_variant="$(
				if test "$_arg_release" == "on"; then {
					echo "${_target_release_dir##*/}";
				} else {
					echo "${_target_debug_dir##*/}";
				} fi
			)";
                _target_workdir="$_target_dir/$_build_variant";
                _used_symbols_statfile="$_target_workdir/.used_symbols";
                _compiled_mod_bundle="$_target_workdir/.lib.compiled.mod";
                _local_build_registrydir="$_target_workdir/.registry";
                local _dirs_to_create=("$_target_debug_dir" "$_target_release_dir" "$_local_build_registrydir");
                mkdir -p "${_dirs_to_create[@]}";
                io::file::check_newline "$_bashbox_meta";
                local _old_new_file_ignore=(-not -path "${_local_build_registrydir}/*");
                cp -r "$_src_dir/". "$_target_workdir/";
                local _dest_file && while read -r _dest_file; do
                    { 
                        if test ! -e "$_src_dir/${_dest_file##"$_target_workdir"}"; then
                            { 
                                rm -r "$_dest_file" || rm -rf "$_dest_file"
                            };
                        fi
                    };
                done < <(find "$_target_workdir" "${_old_new_file_ignore[@]}" -type f);
                unset _old_new_file_ignore;
                printf '' > "$_used_symbols_statfile";
                source "$_bashbox_meta";
                if test -v "$_bashbox_compat_var_name"; then
                    { 
                        local MIN MAX VAR_REF;
                        VAR_REF="${!_bashbox_compat_var_name}";
                        IFS='~' read -r MIN MAX <<< "${VAR_REF}" || true;
                        if test -n "$MIN"; then
                            { 
                                if ! (( $(awk '{print ($1 <= $2)}' <<<"$MIN $___self_VERSION") )); then
                                    { 
                                        log::error "$CODENAME requires at least bashbox $MIN" 1 || exit
                                    };
                                fi
                            };
                        else
                            { 
                                log::error "MIN version is missing from $_bashbox_compat_var_name in $_bashbox_meta_name" 1 || exit
                            };
                        fi;
                        if test -n "$MAX"; then
                            { 
                                if ! (( $(awk '{print ($1 >= $2)}' <<<"$MAX $___self_VERSION") )); then
                                    { 
                                        log::error "$CODENAME supports bashbox upto $MAX" 1 || exit
                                    };
                                fi
                            };
                        fi;
                        unset MIN MAX VAR_REF
                    };
                else
                    { 
                        log::error "$_bashbox_compat_var_name metadata is missing in $_bashbox_meta_name" 1 || exit
                    };
                fi;
                EXPORT_USEMOL="true" subcommand::install "${DEPENDENCIES[@]}";
                _target_workfile="$_target_workdir/$CODENAME"
            ;;
        esac
    };
    function print_help () 
    { 
        println::helpgen "${_self_name^^}" --short-desc "Wannabe bash compiler" --usage "${_self_name} [OPTIONAL-OPTIONS] [SUBCOMMAND] <subcommand-arguments>" --options-desc "-V, --version<^>Print version info and exit
-v, --verbose<^>Use very verbose output
-q, --quiet<^>No output printed to stdout
--offline<^>Run without checking for update
-h, --help<^>Prints this help information" --subcommands "new<^>${SUBCOMMANDS_DESC[1]}
build<^>${SUBCOMMANDS_DESC[2]}
clean<^>${SUBCOMMANDS_DESC[3]}
install<^>${SUBCOMMANDS_DESC[4]}
selfinstall<^>${SUBCOMMANDS_DESC[5]}" --footer-msg "Try '${_self_name} <subcommand> --help' for more information on a specific command.
For bugreports: $___self_REPOSITORY"
    };
    function main () 
    { 
        _self_name="${___self##*/}";
        _arg_verbose=off;
        _arg_quiet=off;
        _arg_offline=off;
        for _arg in "${@}";
        do
            { 
                if test "$_arg" != "--" && [[ "$_arg" == -* ]]; then
                    { 
                        case "$_arg" in 
                            --verbose | -v)
                                _arg_verbose=on
                            ;;
                            --quiet | -q)
                                _arg_quiet=on
                            ;;
                            --offline)
                                _arg_offline=on
                            ;;
                            --version | -V)
                                echo "$___self_VERSION";
                                exit 0
                            ;;
                            --help | -h*)
                                print_help;
                                exit 0
                            ;;
                            -C)
                                cd "$2" || { 
                                    log::error "$2 doesn't exist" || exit
                                };
                                shift
                            ;;
                        esac;
                        shift
                    };
                else
                    { 
                        break
                    };
                fi
            };
        done;
        unset _arg;
        _subcommand_argv="${1:-}" && shift || true;
        case "$_subcommand_argv" in 
            new | run | build | clean | install | selfinstall)
                subcommand::$_subcommand_argv "$@"
            ;;
            *)
                clap "$@";
                source "$_bashbox_meta";
                if declare -F "$_subcommand_argv" &> /dev/null; then
                    { 
                        "$_subcommand_argv" "$@"
                    };
                else
                    { 
                        if test -n "$_subcommand_argv"; then
                            { 
                                log::warn "Unknown subcommand: $_subcommand_argv"
                            };
                        fi;
                        print_help;
                        if test -n "$_subcommand_argv"; then
                            { 
                                exit 1
                            };
                        else
                            { 
                                exit 0
                            };
                        fi
                    };
                fi
            ;;
        esac;
        exit
    };
    main "$@";
    wait;
    exit
}
"main@bashbox%bashbox" "$@";
